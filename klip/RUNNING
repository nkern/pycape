#############
## RUNNING ##
#############

To use klip, import klfuncs into your Python interpretor via
>>> from klip import klfuncs

Then initialize the klfuncs class by feeding it a dictionary with pre-defined variables:
>>> KL = klfuncs(variables)

The desired functions from klip can then be used by calling them from the initialized class "KL"
>>> KL.klinterp(data, ...)

As stated, "variables" must be a dictionary with certain user-defined variables (i.e. variables={'var1':var1, 'var2':var2, etc...}).
To view the necessary variables, see the documentation of desired functions within klfuncs.py

To perform a KL transform of a 2-dimensional data vector ("data") that contains a training set of N_samples number of samples, with each sample being its own row-vector of an independent data set with N_data data points, use the function "klt()."

To produce a data-compressed interpolation function that maps from a parameter space to a final data product, use the function "klinterp()."

To calculate the predicted eigenmodes of a data product from a discrete location in the parameter space, use the function "calc_eigenmodes()." This assumes that klinterp() has already been run.

Example:
--------
Take an example of a data set containing 100 different galaxy spectra, with each spectrum containing 1,000 data values in wavelength.
Each galaxy spectrum is different, and has been generated by a simulation that takes as input N=3 number of parameters.

We would like to know: what does a galaxy spectrum look like at any point in the N-dimensional parameter space in the simulation?

If the simulation takes hours or longer to run, and the parameter space is relatively large and has more than a few dimensions, the cost to evaluate the answer "brute-force" can be computationally expensive. 
Instead, we would like to *interpolate* between the 100 samples of galaxy spectra that we already have.
In brief, this involves creating an interpolation function that maps the parameter space, directly to the data product (in this case a galaxy spectrum).
We do this with Principal Component Analysis, or a Karhunen-Loeve transformation to compress the data onto an new basis, called Eigenmodes, and interpolate the weights of each Eigenmode

For this problem, we want to use the "klinterp()" function found in klip's klfuncs class.
We first need to specify a few variables:
	N_samples	: constant, number of samples in training set (in this case, N_samples=100)
	N_data		: constant, number of data points in data product-of-interest (in this case, N_data = 1000)
	N_params	: constant, number of paramters in parameter space (in this case, N_params = 3)
	N_modes		: constant, number of Eigenmodes used to describe data product-of-interest (can range from 0 to N_data based on preference)
	poly_deg	: constant, degree of polynomial used in interpolation

We want to wrap these variables up in a dictionary and feed it to the class klfuncs() when initializing the class. After following the instructions to load the klip module, we can initialize the klfuncs class by the following:
>>> variables = {'N_samples':100, 'N_data':1000, 'N_params':3, 'N_modes':10, 'poly_deg':9}
>>> KL = klfuncs(variables)

Next, we want to use the klinterp() function to create the interpolation function. We need to feed the function two matrices: data and param_samples.
data is a 2d matrix with shape [N_samples, N_data], meaning it has row-vector galaxy spectra stacked vertically, so that data[0] is the galaxy spectrum from the 0th sample in the training set.
param_samples is a 2d matrix with shape [N_samples, N_params], meaning it has row-vector parameter values from which each galaxy spectrum was generated from, so that param_samples[0] are the values of the 3 parameters used to generate the 0th galaxy spectrum in our simulation.
klinterp() will create N_modes number of Eigenmodes and an analytical function describing their weights that is a function of position in the parameter space.
This is done via
>>> KL.klinterp(data,param_samples)

Now we can answer the question we posed in the first place: what does a galaxy spectrum look like at any given point in the parameter space of our simulation?
To do so, we need klfuncs' "calc_eigenmodes()" function.
To use this function, all we need to do is feed it with a list of our desired parameter values, but they have to each be wrapped in a list. For example
>>> KL.calc_eigenmodes( [ [0.01], [1.5], [152] ] )

will use the results of KL.klinterp() and our user-defined variables to generate a guess as to what a galaxy spectrum would look like in our simluation with param1=0.01, param2=1.5 and param2=152.
This information is stored as the variable KL.data_product


** For another fully-worked example, see the EXAMPLE/ directory **

